# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature user
#
# -----------------------------------------------------------------------

# user -- facilities providing the user management for the Fuzion
# webserver
#
module user (module base_dir path) is

  config := config_file.open (base_dir.resolve user.user_file)
  log_path := base_dir.resolve user.log_file
  _ /* run_dir_path */ := base_dir.resolve user.run_dir


  # verify username password combination
  #
  module verify_login (username, password String) =>
    if name = username || email = username || login = username
      match password_hash
        nil => false
        hash String =>
          res := crypto.password_hash_verify password hash
          log (res ? "successful login" : "*** failed login attempt")
          res
    else
      false


  # log a message to this users' log file
  #
  module log (s String) =>
    logger.log log_path s


  # name of the user
  #
  module name =>
    config["name"]


  # email of the user
  #
  module email =>
    config["email"]


  # login of the user
  #
  module login =>
    config["login"]


  # password pepper-id of the user
  #
  module password_pepper_id =>
    config["password.pepper-id"]


  # password hash of the user
  #
  module password_hash =>
    config["password.hash"]


  # does the user have a registration token?
  #
  module has_registration_token =>
    config["registration_token"].exists


  # groups of the user
  #
  module groups =>
    config["groups"]


  # deletion token of the user
  #
  deletion_token =>
    config["deletion_token"]


  # checks if groups_to_check contains a group in groups
  #
  # groups_to_check and groups are both separated by " "
  #
  module check_group_access (groups_to_check String) =>
    groups0 := container.set_of_ordered (groups.val "").split
    checked_groups := container.set_of_ordered groups_to_check.split
    common_groups := groups0 ∩ checked_groups

    match common_groups.size_option
      nil => false
      size i32 =>
        if size > 0
          true
        else
          check_for_all := checked_groups.contains "all"
          access_to_all := groups0.contains "all"
          check_for_any := (groups0.size_option.val 0) > 0 && checked_groups.contains "any"
          check_for_all || check_for_any || access_to_all


  # send email for account deletion confirmation
  #
  trigger_deletion outcome unit =>
    token := user.generate_uuid
    config.set0 "deletion_token" token
    config.save
    subject := "[fuzion-lang.dev] - Confirm account deletion"
    io.file.read (content.templates_dir.resolve "email_account_deletion.txt")
      .bind (tmplt ->
              body := tmplt.replace "##NAME##" (name.val "fuzion-lang.dev user")
                           .replace "##TOKEN##" token

              email_service.send_text_mail_with_footer user.noreply_tokiwa_software (email.val "") subject body)



  # get a list of the directory entries
  #
  type.list_dir (p path) array String =>
    res := io.dir.use _ p.as_string ()->
      for
        entries := (container.expanding_array String).empty, entries.add next.get
        next := io.dir.open.read
      until !next.ok
        entries

    match res
      error => []
      ea container.expanding_array => ea.as_array


  # given a path of a user directory, check if the given predicate applies
  #
  type.check_user (predicate user->bool, p path) bool =>
    match io.file.stat p.as_string true
      error => false
      m io.file.meta_data =>
        if m.is_dir
          u := user p
          predicate u
        else
          false


  # verify the password of the given user, and return the user
  # in case the password is correct
  #
  module type.get (username, password String) =>
    get_user u->
      !u.has_registration_token && u.verify_login username password


  # get user by loginname or email
  #
  module type.get (login_or_email String) =>
    get_user u->
      u.login = login_or_email || u.email = login_or_email


  # get user by a deletion token
  #
  module type.get_by_deletion_token (token String) =>
    get_user u->
      u.deletion_token = token


  module type.get_user(predicate user->bool) outcome user =>
    for
      f in (list_dir users_dir)
      user_dir := users_dir.resolve f
    until check_user predicate user_dir
      user user_dir
    else
      error "no user found"


  # get the default user
  #
  module type.default_user user =>
    user (users_dir.resolve no_user)


  # register a using the data submitted by the form
  #
  module type.register (client net.ip_address, form_data lock_free.Map String String) outcome String =>
    full_name (first, last, email String) =>
      full0 := "{first} {last}".trim
      full0.is_empty ? email : full0

    validate_mail(str String) =>
      s := str.split "@" .as_array
      if s.count != 2
        logger.log "illegal mail address: {str}"
        false
      # NYI: UNDER DEVELOPMENT: allow non ASCII mail addresses?
      else if !(str.utf8 ∀ b->
          # ASCII but no space and no control character
          0x21 <= b <= 0x7E)
        logger.log "illegal mail address: >{str}<"
        false
      else
        true


    first_name := (form_data[form_data_first_name].val "").trim
    last_name := (form_data[form_data_last_name].val "").trim
    affiliation := (form_data[form_data_affiliation].val "").trim
    username0 := form_data[form_data_username]
    email0 := form_data[form_data_email].bind (.trim)
    password0 := form_data[form_data_password]
    terms := "on" = form_data[form_data_terms].val "off"
    newsletter := "off" = form_data[form_data_newsletter].val "off"

    if email0.is_nil || username0.is_nil || password0.is_nil || !terms
      error "Required fields not present: email, username, password, accepting terms."
    else if email0.get.contains "," || email0.get.contains ";"
      # NYI: HACK: comma and semicolon actually allowed in local part if quoted
      error "Comma or semicolon in email are not allowed."
    else if !(validate_mail email0.get)
      error "Email address invalid."
    else if !(username0.get.utf8 ∀ c->(0x30 ≤ c ≤ 0x39 | 0x41 ≤ c ≤ 0x5a | 0x61 ≤ c ≤ 0x7a | c = 0x5f))
      error "Username contains illegal characters. Only A-Z, a-z, 0-9, and _ are allowed."
    else if !(3 < username0.get.codepoint_length < 100)
      error "Username must have at least three characters and must not be longer than 100 characters."
    else
      full_name := full_name first_name last_name email0.get

      match create_user_txt first_name last_name full_name affiliation username0.get email0.get password0.get terms newsletter time.now.get.as_string
        error => "<div class='text-center'>Registration failed. Already registered?</div>"
        token String =>
          logger.log "send registration token email to: {email0}"

          match send_user_registration_email full_name email0.get token username0.get $client
            error => "<div class='text-center'>Registration failed. Failed sending mail.</div>"
            unit => "<div class='text-center'>Registration successful. Please check your mail and confirm the registration.</div>"


  # complete registration with token from email
  #
  module type.complete_registration (username, token String) outcome unit =>
    if username.contains "." || username.contains "/" || username.is_empty
      error "Dots and slashes in username are not allowed."
    else
      user_text := user.users_dir
                       .resolve username
                       .resolve user.user_file
      c := config_file.open user_text

      if c["registration_token"].val "" = token
        _ := c.remove "registration_token"
        c.save


  # create and store user information on the file system
  #
  type.create_user_txt (first_name, last_name, full_name, affiliation, username, email, pazzword String, terms, newsletter bool, date String) outcome String =>
    user_dir := user.users_dir.resolve username
    user_text := user_dir.resolve user.user_file
    if io.file.exists user_text.as_string
      error "*** user already exists: {username}"
    else
      match io.dir.make user_dir.as_string
        e error => e
        unit =>
          token := generate_uuid

          entries := [
            ("name", full_name),
            ("first_name", first_name),
            ("last_name", last_name),
            ("affiliation", affiliation),
            ("email", email),
            ("login", username),
            ("password.pepper-id", "0".as_string),
            ("password.hash", id String (hash_password pazzword)),
            ("groups", "users"),
            ("terms_accepted", terms.as_string),
            ("newsletter", newsletter.as_string),
            ("registration_date", date),
            ("registration_token", token)
          ]
          m := map_of_strings entries

          c := config_file m user_text
          c.save

          token


  # generate a uuid
  #
  type.generate_uuid String =>
    uuid.create_random.as_string


  module type.trigger_account_deletion (client net.ip_address, form_data lock_free.Map String String) String =>
    if has_triggered_account_deletion_recently client
      "<div class='text-center'>Only one deletion request per IP possible within 10 minutes.</div>"
    else
      standard_text := "<div class='text-center'>If the account exists an E-Mail has been sent to complete the deletion</div>"
      match form_data["username_or_email"]
        nil => standard_text
        username_or_email String =>
          match get username_or_email
            error => standard_text
            u user =>
              logger.log "User requested deletion: {u.email}."
              match u.trigger_deletion
                e error =>
                  logger.log "user.delete_account not successful."
                  logger.log e
                  "<div class='text-center'>There was an error sending the E-Mail.</div>"
                unit => standard_text


  # has given client triggered an account deletion
  # in the last 10 minutes?
  #
  type.has_triggered_account_deletion_recently (client net.ip_address) bool =>
    # NYI
    false


  #
  #
  module type.complete_account_deletion (token String) outcome unit =>
    # simplify by passing username in link
    match get_by_deletion_token token
      error => error "no user found with token: {token}"
      u user =>
        if !(io.file.exists deleted_users_dir.as_string)
          io.dir
            .make deleted_users_dir.as_string
            .or_else (() -> u.log "failed making dir: {deleted_users_dir}")

        io.file.move u.base_dir.as_string "{deleted_users_dir}/{time.now}"


  # send email with account confirmation link
  #
  type.send_user_registration_email (name, email, token, username, ip String) outcome unit =>
    # NYI - prevent abuse
    subject := "[fuzion-lang.dev] - Confirm registration"
    io.file.read (content.templates_dir.resolve "email_registration.txt")
      .bind (tmplt ->
              body := tmplt.replace "##NAME##" send_user_registration_email.this.name
                           .replace "##USERNAME##" username
                           .replace "##TOKEN##" token
                           .replace "##IP##" ip
              email_service.send_text_mail_with_footer noreply_tokiwa_software email subject body)


  # constants
  #
  type.noreply_tokiwa_software => "noreply@tokiwa.software"

  type.users_dir => path.of "./users"
  type.deleted_users_dir => path.of "./users_deleted"
  type.user_file => "user.txt"
  type.log_file => "log.txt"
  type.run_dir => "runDir"

  type.no_user => "--no-user--"

  type.form_data_first_name => "first_name"
  type.form_data_last_name => "last_name"
  type.form_data_affiliation => "affiliation"
  type.form_data_username => "username"
  type.form_data_email => "email"
  type.form_data_password => "password"
  type.form_data_newsletter => "newsletter"
  type.form_data_terms => "terms"
