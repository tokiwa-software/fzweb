# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature session_document
#
# -----------------------------------------------------------------------


# session_document -- features used to handle documents that are rendered for a
# specific session
#
module session_document (module page String,
                         session Session) is

  # path to this document as an abstract path
  #
  data_path := content.get_data_path session.user.read page


  # the actual file name of the current document
  #
  file_name := data_path.file_name


  # is the user of the given session allowed to
  # access the requested page?
  #
  permitted := content.access_permitted session.user.read page


  # get file content as array of strings
  #
  module get_content array String =>
    lm ! ()->
      res := (mutate.array String).empty lm

      match util.read_file_as_string data_path
        str String =>
          if permitted
            res.add (navigation true)

          res.add "<div class='fd-page-content'>"

          if file_name.ends_with ".html"
            html := add_session_info_to_html str

            if has_embedded_html html
              res.add (embed_html_in_iframe html)
            else
              res.add html
          else if content.is_known_preformatted_file file_name

            # NYI: UNDER DEVELOPMENT: pretty printing

            title := (content.file_path page).as_string
            res.add "<h1>{util.url_encoded.html_encode title.as_string}</h1>\n"
            # opacity is reset in main.js:initAnsiUp()
            res.add "<pre class='code' style='opacity: 0'>\n"
            str.lines .for_each line->
              res.add <| util.url_encoded.html_encode line
            res.add "</pre>\n"
          else
            fname := util.url_encoded.html_encode data_path.file_name
            res.add "<p>501: Not Implemented: Unsupported file type in {fname}</p>"

          res.add "</div>"

          match io.file.stat data_path.as_string true
            e error =>
              session.log "error retrieving file metadata in session_document get_content: {e}"
            metadata io.file.meta_data =>
              ts := time.date_time.from_seconds metadata.mtime.as_u64
              ts_formatted := "{ts.year.as_string 4 10}-{ts.month.as_string 2 10}-{ts.day.as_string 2 10}"
              res.add "<div class='last-changed'>last changed: {ts_formatted}</div>"

          if permitted
            res.add (navigation false)
        error => res.add "<p>404: page not found</p>"

      res.as_array


  # add session-specific information to the html
  #
  add_session_info_to_html (s String) String =>
    s
      .replace "##SESSION_ID##" session.session_id
      |> replace_tag "runcode" runcode_wrapper
      |> replace_tag "page" page_tag
      |> replace_tag "browse" browse_tag


  # page tag replacer, used to replace HTML this:
  #
  # <page file="sqlite/index" />
  #
  page_tag(m container.Map String String) =>
    path
      .of page
      .parent
      .val
      .resolve m["file"].get
      .as_string
      |> page_link


  # browse tag replacer, used to replace HTML this:
  #
  # <browse dir="../../link/clang/src/"/>
  #
  browse_tag(m container.Map String String) =>

    append(a String, md io.file.meta_data) =>
      if md.is_dir
        dir_map := container.ordered_map ["dir"] [a]
        """
          <div class="mydir" data-dir"{util.url_encoded.html_encode a}">NYI: {browse_tag dir_map}</div>
        """
      else if md.is_regular
        """
          <div><a href="{a}">NYI: {util.url_encoded.html_encode (String.join ((path.of a).names.drop data_path.parent.val.names.count) "/")}</a></div>
        """
      else ""

    dir := data_path
      .parent
      .val
      .resolve m["dir"].get
      .as_string

    io.dir
      .use dir ()->
        for res := container.expanding_array String .empty,
            {
              x := "{dir}/{a.val}"
              match io.file.stat x false
                e error => res
                md io.file.meta_data => res.add <| append x md
            }
            a := io.dir.open.read
        while a.ok
        else
          String.join res
      .or_else ""


  # add run code wrapper for code in file `file`
  #
  runcode_wrapper(m container.Map String String) =>
    id := uuid.create_random.as_string
    code := util
      .read_file_as_string (data_path.parent.val.resolve m["file"].get).as_string
      .val
    """
    <div class="runcode-wrapper">
      <i class="far fa-spinner fa-spin"></i>
      <div class="mb-15 runcode" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(min(100%,40ch), min(100%, 80ch))); max-width: 102rem; opacity: 0;">
        <div class="position-relative">
          <form id="{id}">
            <label for="{id}.code" class="visually-hidden">Code input</label>
            <textarea class="codeinput" required="required" maxlength="4096" id="{id}.code" name="code" rows="{max 3 code.lines.count}" spellcheck="false">{code}</textarea>
            <div class="position-absolute runbuttons">
              <input type="button" onclick="runit('{id}')"    class="runbutton" value="Run!" />
              <input type="button" onclick="runiteff('{id}')" class="runbutton" value="Effects!" />
              <a href="/tutorial/effects.html"><i>What are effects?</i></a>
            </div>
          </form>
        </div>
        <div class="computeroutput" id="{id}.result"></div>
      </div>
    </div>
  """


  # replace tag `tag` by some custom html
  #
  # e.g. for this String
  #
  # """
  #  <div class="itembody">
  #    <page file="lock_free/index.html" /><br>
  #  </div>
  # """
  #
  # and call replace_tag "page" λ
  #
  # the λ would be called with this String: "lock_free/index.html"
  #
  replace_tag(tag String, replacer (container.Map String String)->String, str String) =>

    # extract attribute contents from a String, helper method for recursion
    # like: <page file="http/index" />
    #
    extract_attribute_contents (s String, m container.ordered_map String String) container.ordered_map String String
    =>
      st := s.trim_start

      if st.is_empty
        m
      else
        a := st.split_n "=\"" 1
        match a.first
          nil =>
            session.log "invalid attribute string on $page (no attribute found): $st"
            m
          k String =>
            match a.nth 1
              nil =>
                session.log "invalid attribute string on $page (no value found): $st"
                m
              ppv String =>
                pv := ppv.split_n "\"" 1
                match pv.first
                  nil =>
                    session.log "invalid attribute string on $page (end of value not found): $st"
                    m
                  v String =>
                    nm := m.add k v
                    rest := pv.nth 1 .val ""
                    extract_attribute_contents rest nm


    # extract attribute contents of a String like
    #
    #   file="http/index.html"
    #
    # or
    #
    #   userdata="true"
    #
    # and store the attributes in a map
    #
    extract_attribute_contents (s String) container.ordered_map String String
    =>
      extract_attribute_contents s (container.ordered_map String String .empty)

    start := "<$tag "
    end := "/>"

    for res := "", res + rest.substring 0 m_idx.val + (match e_idx
                                                        nil => ""
                                                        e i32 =>
                                                          attr := rest2.substring 0+start.byte_length e
                                                          replacer (extract_attribute_contents attr))
        rest String := str,
          match e_idx
            nil => ""
            e i32 =>
              rest2.substring e+end.byte_length
        m_idx := rest.find start
    while m_idx.ok
      rest2 := rest.substring m_idx.val
      e_idx := rest2.find end
    else
      res + rest


  # given an HTML document, check if a closing tag "</html>" is present
  #
  has_embedded_html(html String) bool =>
    !(html.find "<!DOCTYPE html>").is_nil && !(html.find "</html>").is_nil


  # check if the html structure correct than replace the iframe tag
  #
  embed_html_in_iframe(html String) String =>
    match html.find "<!DOCTYPE html>"
      c i32 =>
        match html.find "</html>"
          c2 i32 =>
            embedded_html := html.substring c c2+7
            html.replace embedded_html """
              <div class="responsive-container aspect-16-by-9">
                <iframe class="responsive-iframe" sandbox="allow-same-origin allow-scripts" id='iframe-embedded-content' data-src-doc-content="{(embedded_html.replace "&quot;" "REPLACEDHTMLQUOTE").replace "" "REPLACEDDOUBLEQUOTE"}">
                </iframe>
              </div>
              """
          nil => html
      nil => html


  # generate a link to a page
  #
  # example:
  #
  # `page_link "tutorial/helloworld"`
  # results in
  # <a class="shylinkfix" href="/tutorial/helloworld">"Hello, World!" Example</a>
  #
  page_link (to String)
    pre debug: !to.starts_with "/"
  =>
    title := document.get_title to (content.get_data_path_unsafe session.user.read to)
    template.page_link to title


  # feature to generate the navigation menu for this document
  #
  # the menu consists of these things:
  #
  # - a title bar with clickable links at the top of the page (also
  #   called the `navtitle` in HTML)
  # - three arrows at the top and the bottom of the page to navigate
  #   the pages
  # - a so called "attractive link", which is a large button at the
  #   bottom of the page for getting to the next page (if available)
  #
  # the argument `top` indicates whether it is the top or bottom menu
  # that is being generated.
  #
  navigation (top bool) String =>
    fn := (content.file_path page).as_string
    pp := content.base_simple_path page
    is_toc := fn = "index"
    pup option path :=
      if is_toc
        pp
      else
        match pp
          nil => path.of "index"
          p path => p.resolve "index"

    # generate a title bar (also called `navtitle`) in the form of
    #
    #   main • dir1 • dir2 • file
    #
    # with links to each of those pages
    #
    generate_title_bar String =>
      # we start with a link to the current page
      temp :=
        # we link to the docs if necessary
        if page.starts_with "docs/"
          (template.doc_links fn) + (page_link page)
        else
          page_link page

      # to recurse upward in the directory tree, this helper feature is used
      #
      # the current state of the title bar is stored as `current`, and `ppup`
      # is the current level in the directory hierarchy
      #
      for current := temp, (page_link (template.link ppup.get.parent "index")) + " • " + current
          ppup := pup, ppup.get.parent
      while ppup.ok
      else
        current

    toc := read_toc_from_index_html

    # get the index in the toc, or nil if none
    #
    idx =>
      if is_toc
        nil
      else
        j := toc.index_of fn
        if j.is_nil && !(fn.ends_with ".html")
          toc.index_of "$fn.html"
        else
          j

    prev, next := idx
      .bind x->
        (if x>0 then toc.nth x-1 else nil, toc.nth x+1)
      # NYI: UNDER DEVELOPMENT: better type inference necessary
      .or_else (id (option String) nil, id (option String) nil)

    attractive_next :=
      next.bind x->
        l := pp
          .bind (p -> p.resolve x .as_string)
          .or_else x
        template.attractive_link l (is_toc ? "start: " : "next: ") + (document.get_title l (content.get_data_path session.user.read l))

    arrow_link(str String) =>
      "<i class='far fa-angle-$str' aria-hidden='true'></i>"

    # generate the link to navigate upwards
    # with respect to a given path
    #
    up_link (p option path) String =>
      p.bind x->
        template.nav_link x.parent "index" (arrow_link "up") "aria-label='up a level'"
       .or_else (template.nav_link nil nil (arrow_link "up") "aria-label='up a level'")

    """
      <div class='d-flex justify-content-between'>
        {top ? "<div class='navtitle'>{generate_title_bar}</div>" : attractive_next.or_else ""}
        <div class='d-flex justify-content-between w-75 {top ? "nav_top" : "nav_bot"}'>
          <div class='nav_left'>{template.nav_link pp prev (arrow_link "left")  "aria-label='previous item'"}</div>
          <div class='nav_up'>{up_link pup}</div>
          <div class='nav_right'>{template.nav_link pp next (arrow_link "right") "aria-label='next item'"}</div>
        </div>
      </div>
    """


  # extracts toc from index.html
  #
  # returns e.g. ["helloworld", "feature_decl", "feature_decl_fields", ...] for tutorial
  #
  read_toc_from_index_html =>

    # NYI: CLEANUP: code is a ugly and inefficient

    res := mut ((container.expanding_array String) .empty)
    match util.read_file_as_string <| data_path.parent.get.resolve "index.html"
      s String =>
        _:= s
          |> replace_tag "page" m->
            if m["file"].ok
              res <- res.add m["file"].val
            ""
        _:= s
          |> replace_tag "browse" m->
            if m["dir"].ok
              res <- res.add m["dir"].val
            else
              res <- res.add "--no directory--"
            ""
      error =>
    res.as_array


# local mutate effect used in this file
#
lm : mutate is
