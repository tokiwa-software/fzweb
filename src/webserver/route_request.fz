# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature route_request
#
# -----------------------------------------------------------------------

# check if the given client has registered within the last ten minutes
#
has_registered_recently (client list u8) bool =>
  # NYI: UNDER DEVELOPMENT:
  false


# create a user account given the data submitted via the form content
#
do_register (client list u8, form_data lock_free.Map String String) String =>
  if has_registered_recently client
    "<div class='text-center'>Only one registration per IP possible within 10 minutes.</div>"
  else
    # NYI: UNDER DEVELOPMENT: registration rate limit, add logging.
    match user.register form_data
      rr String => rr
      e error => "<div class='text-center'>*** Registration failed: {e}</div>"


# construct a response for account registration
#
confirm_registration(s Session, query String) =>
  s_q := util.split_query query
  webserver.this.log s "got confirm_registration"
  match user.complete_registration (s_q["username"].val "") (s_q["token"].val "")
    unit =>
      webserver.this.log s "got confirm_registration send 302 success"
      response.new 302 (map_of_strings [("Location", "/registration_successful")])
    e error =>
      webserver.this.log s "got confirm_registration send 302 failure: "+e
      response.new 302 (map_of_strings [("Location", "/registration_failed")])


# construct a response for account deletion
#
confirm_account_deletion(s Session, query String) =>
  s_q := util.split_query query
  webserver.this.log s "got confirm_account_deletion"
  match user.complete_account_deletion (s_q["token"].val "")
    unit =>
      webserver.this.log s "got confirm_account_deletion send 302 success"
      response.new 302 (map_of_strings [("Location", "/account_deletion_successful")])
    e error =>
      webserver.this.log s "got confirm_account_deletion send 302 failure"
      logger.log e.as_string
      response.new 302 (map_of_strings [("Location", "/account_deletion_failed")])


# handle goto events
#
# sends data via the /event connection
#
goto(s Session, form_data lock_free.Map String String) =>
  match form_data["page"]
    page String =>
      match content.get_contents s page
        forbidden => webserver.this.log s "*** forbidding access to absolute or non-normalized page {page}."
        missing => webserver.this.log s "error: requested file {page} does not exist"
        i identifier =>
          match i.simple_path
            sp String =>
              s.set_current sp
              s.send_content
            nil =>
              webserver.this.log s "error: identifier, no simple_path: {i}"
    nil =>
      webserver.this.log s "error: page not found in form_data: {form_data}"


# open the event sourcing connection
#
# this connection is then used to send back events to the user
# e.g. when running code example, login status etc.
#
events(s Session) =>
  response 200 (map_of_strings [("Cache-Control", "no-cache"), ("Connection", "keep-alive"), ("Content-Type", "text/event-stream"), ("Transfer-Encoding", "chunked")]) [] s


# send content and login status via session
#
send_content_and_login_status(s Session) =>
  s.send_content
  s.send_login_status


# get current session
#
session(form_data lock_free.Map String String, client list u8) Session =>
  sessid_original := form_data["originalsessionid"]
  sessid := form_data["sessionid"]
  Session.get sessions sessid_original sessid client


# send robots.txt
#
robots_txt =>
  r := content
    .templates_dir
    .resolve "robots.txt"
  match util.read_file_as_string r
    str String =>
      send_ok str
    error =>
      logger.log "robots.txt could not be read."
      response.new 500


# send page/file that was accessed
#
get_file_response(s Session, form_data lock_free.Map String String, raw_path String) =>
  perform_direct_login s form_data
  path := encodings
    .percent
    .decode_as_str_tolerant raw_path
    .val
  match content.get_contents s path
    forbidden =>
      webserver.this.log s "*** forbidding access to absolute or non-normalized path {path}."
      response.new 403
    missing =>
      webserver.this.log s "*** error: requested file {path} does not exist"
      response.new 404
    i identifier => i.response s


# routes a given request to the code that handles it,
# and returns the response
#
module route_request (raw_path0 String, cmd http.request_method, client list u8, form_data lock_free.Map String String, query String) response =>

  s =>
    session form_data client

  raw_path := if raw_path0.ends_with "/" then raw_path0 + "index.html" else raw_path0

  # NYI: PERFORMANCE: order ifs by most used / accessed

  if cmd != http.get && cmd != http.head && cmd != http.post_r
    logger.log "*** unknown request: {cmd}"
    response.new 501
  else if raw_path = "/login"
    s.login form_data["login"].val form_data["password"].val
    send_ok_or_reload s s.status_string
  else if raw_path = "/logout"
    s.logout
    send_ok_or_reload s s.status_string
  else if cmd = http.post_r && raw_path = "/register"
    send_ok (do_register client form_data)
  else if cmd = http.post_r && raw_path = "/delete_account"
    send_ok (user.trigger_account_deletion client form_data)
  else if raw_path = "/confirm_account_deletion"
    confirm_account_deletion s query
  else if raw_path = "/confirm_registration"
    confirm_registration s query
  else if raw_path = "/robots.txt"
    robots_txt
  else if raw_path = "/goto"
    goto s form_data
    send_ok_or_reload s
  else if raw_path = "/run"
    runner.run s form_data
    send_ok_or_reload s
  else if raw_path = "/runeff"
    runner.runeff s form_data
    send_ok_or_reload s
  else if raw_path = "/playground"
    send_nyi
  else if raw_path = "/events"
    events s
  else if raw_path = "/contents"
    send_content_and_login_status s
    send_ok_or_reload s
  else if raw_path = "/api/benchmark/logs"
    send_nyi
  else
    get_file_response s form_data raw_path


# perform a login alongside an ordinary request
#
perform_direct_login (s Session, form_data lock_free.Map String String) =>
  l := form_data["login"]
  p := form_data["password"]

  if l?? && p??
    webserver.this.log s "Direct login: for {l.get}"
    s.login l.get p.get
