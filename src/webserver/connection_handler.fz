# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature connection_handler
#
# -----------------------------------------------------------------------

# contains convenient access of request
# like header fields, a send feature etc.
#
request_context (LM type : mutate, connection net.connection) is
  request := (http.read_request LM).get

  path => (request.target.split "?").first.get
  query_string => ((request.target.split "?").drop 1).first ""

  client =>
    match net.channel.env.get_peer_address
      x Sequence u8 => x.as_list
      error => [u8 0, 0, 0, 0].as_list

  # send an HTTP response on the current socket
  #
  # return_code specifies the HTTP status code of the response
  # attributes defines the headers of the response
  # data contains the body of the response as an array of bytes
  #
  send(return_code i32, attributes lock_free.Map String String, data array u8) =>
    attributes.put "Server" "Fuzion WebServer v0.0.2"
    if !attributes["Connection"].exists
      attributes.put "Connection" "close"

    lm2 ! ()->
      br := array_read_handler lm2 data
      response := http.response_message.new request 1 1 return_code "OK" attributes.items.as_array br

      match ((io.buffered LM)
          .writer.env
          .write (response.bytes data.count)
          .error)
        e error => logger.log "#### {e}"
        unit =>
          flush_ok := (io.buffered LM).writer.env.flush
          if flush_ok!!
            logger.log "#### {flush_ok.err}"


# entry point to the handling the request
#
module handle_connection (LM type : mutate, conn net.connection) unit =>
  req_context := request_context LM conn
  logger.log "{req_context.request.method} {req_context.request.target}"

  process_request LM req_context

# extract form data from request_context
#
form_data(LM type : mutate, req_context request_context LM) =>
  post_len =>
    match (req_context.request.header["content-length"].or_else "0").parse_i32
      error => 0
      i i32 => i
  post_data_raw := lm2 ! ()->
    (io.buffered lm2).reader req_context.request.body ! ()->
      (io.buffered lm2).read_bytes post_len
  post_data := String.from_bytes post_data_raw.as_list
  val := util.mime_value.from_type_string (req_context.request.header["content-type"].get "")
  content_type := val.mime_type
  content_type_boundary := val["boundary"]
  get_form_data post_data req_context.request.method req_context.query_string content_type content_type_boundary


# get the response for the current request
#
get_response(LM type : mutate, req_context request_context LM) =>
  match form_data req_context
    x lock_free.Map String String =>
      route_request req_context.path req_context.request.method req_context.client x req_context.query_string
    e error =>
      logger.log e
      response.new 415 (map_of_strings [("Accept", "application/x-www-form-urlencode, multipart/form-data")])


# helper to process the request
#
process_request(LM type : mutate, req_context request_context LM) =>

  resp := match req_context.request.method
    http.get => get_response req_context
    http.post_r => get_response req_context
    * => response.new 500

  req_context.send resp.returncode resp.attributes resp.data.as_array
  match resp.session
    nil =>
    s Session =>
      s.set_connection req_context.connection


# file local mutate
#
lm2 : mutate is


# custom read handler for reading from an array (helper feature)
#
array_read_handler(LM type : mutate, arr array u8) : io.Read_Handler is


  # position indicator for the read feature
  #
  pos := LM.env.new 0

  # read `count` bytes from the array and "discard" them (by setting a position
  # indicator)
  #
  public redef read(count i32) choice (array u8) io.end_of_file error =>
    p := pos.get
    if p >= arr.count
      io.end_of_file
    else
      pos <- p + count
      end := p+count > arr.count ? arr.count : p+count
      arr.slice p end .as_array
