# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature connection_handler
#
# -----------------------------------------------------------------------

# contains convenient access of request
# like header fields, a send feature etc.
#
request_context (LM type : mutate, request http.request_message) is

  path => (request.target.split "?").first.get

  query_string => ((request.target.split "?").drop 1).first ""

  x_forwarded_for := request.header["x-forwarded-for"]
    .or_else ""
    .split ","
    .first ""
    .trim
    |> net.ip_address.type.from_string

  client :=
    x_forwarded_for
      .or_else (net.channel.env.get_peer_address.or_else (net.ip_address (u128 0 0)))

# entry point to the handling the request
#
module handle_connection (LM type : mutate, req http.request_message) =>
  req_context := request_context LM req
  logger.log "{req_context.request.method} {req_context.request.target}"

  process_request LM req_context


# extract form data from request_context
#
form_data(LM type : mutate, req_context request_context LM) =>

  # get the content length from the headers
  #
  content_length =>
    req_context
      .request
      .header["content-length"]
      .or_else "0"
      .parse_i32
      .or_else 0

  lm : mutate is
  post_data_raw := lm ! ()->
    (io.buffered lm).reader req_context.request.body ! ()->
      (io.buffered lm).read_bytes content_length
  post_data := String.from post_data_raw
  val := util.mime_value.from_type_string (req_context.request.header["content-type"].val "")
  content_type := val.mime_type
  content_type_boundary := val["boundary"]
  get_form_data post_data req_context.request.method req_context.query_string content_type content_type_boundary


# get the response for the current request
#
get_response(LM type : mutate, req_context request_context LM) =>
  match form_data req_context
    x lock_free.Map String String =>
      route_request req_context.path req_context.request.method req_context.client x req_context.query_string
    e error =>
      logger.log e
      response.new 415 (map_of_strings [("Accept", "application/x-www-form-urlencode, multipart/form-data")])


# helper to process the request
#
process_request(LM type : mutate, req_context request_context LM) =>

  resp := match req_context.request.method
    http.get => get_response req_context
    http.post_r => get_response req_context
    * => response.new 500

  match resp.session
    nil =>
    _ Session =>
      # s.set_connection req_context.connection

  resp.response_message LM
