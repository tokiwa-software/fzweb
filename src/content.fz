# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature content
#
# -----------------------------------------------------------------------

# content -- features for working with the content stored on the file system
#
module content is

  # Base directory corresponding to simple_path.
  #
  # This base directory will contain the pages subdirectory
  # and the access.txt file.
  #
  type.base_dir (simple_path String) path =>
    bp := base_simple_path simple_path
    bp?? ? content_dir.resolve bp.get : content_dir


  # Base directory corresponding to simple_path, or nil
  # if it could not be found.
  #
  # This base directory will contain the pages subdirectory
  # and the access.txt file.
  #
  module type.base_simple_path (simple_path String) option path =>
    sp := path.of simple_path

    base_simple_path_loop_helper (i i32) option path =>
      if i > 0
        base_simple_path := sp.subpath 0 i
        base_dir0 := content_dir.resolve base_simple_path
        access := base_dir0.resolve "access.txt"

        if io.file.exists access.as_string
          base_simple_path
        else
          base_simple_path_loop_helper i-1
      else
        nil

    base_simple_path_loop_helper sp.names.count


  # The file part of a simple_path.
  #
  module type.file_path (simple_path String) path =>
    bp := base_simple_path simple_path
    sp := path.of simple_path
    start i32 := bp!! ? 0 : bp.get.names.count
    end i32 := sp.names.count
    start < end ? sp.subpath start end : path.of ""


  # look the given attribute in the access.txt file
  # for simple_path
  #
  type.access_attr (simple_path, attribute, default String) String =>
    access_file := (base_dir simple_path).resolve "access.txt"
    c := config_file.open access_file.as_string
    a := c.get attribute
    a.get default


  # Check if access to a given path is permitted for user u.
  #
  module type.access_permitted (u option user, simple_path String) bool =>
    groups := access_attr simple_path "groups" ""
    match u
      u0 user => u0.check_group_access groups
      nil =>
        for
          s in (groups.split " ")
        until s = "all"
          true
        else
          false


  # Check if the given path points to a directory that contains an index.html
  # file that contains a <browse> tag to browse a directory.
  #
  type.is_browsable (jndex path) option (lock_free.Map String String) =>
    if io.file.exists jndex.as_string
      util
        .read_file_as_string jndex.as_string
        .bind str->
          for
            l in str.split "\n"
            m := document.get_tag l "<browse"
          until m.exists
            outcome m.get
          else
            error "not found"
        .as_option
    else
      nil


  # pages dir for a given path prefix
  #
  type.pages_dir (simple_path String) path =>
    (base_dir simple_path).resolve pages_dir_relative


  # index file for a given directory containing pages
  #
  type.index_file (pages path) path =>
    pages.resolve "index.html"


  # Get the relative directory from a <browse> tag. This is either
  # the value of the attribute "dir" or, if attribute "userdata" is
  # "true", the user directory.
  #
  type.get_dir_from_browse (u option user, data_path path, map lock_free.Map String String) option String =>
    if "true" = (map["userdata"].get "false")
      u.bind String u0->
        ud := path.of u0.base_dir
        ru := data_path.parent.get.relativize ud
        ru.as_string
    else
      map["dir"]


  # check if a file is known to be preformatted
  #
  module type.is_known_preformatted_file (file_name String) bool =>
    file_name.ends_with ".c" ||
      file_name.ends_with ".fz" ||
      file_name.ends_with ".fuzion" ||
      file_name.ends_with ".sh" ||
      file_name.ends_with ".txt" ||
      file_name.ends_with ".ebnf"


  # Get the data path to the contents of the given simple URL path after it had
  # been checked that we have permission to access it.
  #
  type.get_data_path2 (u option user, simple_path String) path =>
    pages := pages_dir simple_path
    html_file := mut simple_path

    if !(html_file.ends_with ".html") && !(is_known_preformatted_file html_file)
      html_file <- html_file + ".html"

    r := pages.resolve (file_path html_file)
    if !(io.file.exists r.as_string)
      index_file pages
      # NYI browsing
    else
      r


  type.path_from_access (simple_path, attribute, default String) path =>
    val := access_attr simple_path attribute default
    bd := base_dir simple_path
    bd.resolve val


  # Get the data path to the contents of the given simple URL path and check if
  # the given user (or nil if none) is allowed to access it.
  #
  module type.get_data_path (u option user, simple_path String) path =>
    if access_permitted u simple_path
      get_data_path2 u simple_path
    else
      if u!!
        path_from_access simple_path "alternative.need.login" "need_login.html"
      else
        path_from_access simple_path "alternative.access.denied" "access_denied.html"


  # Determine the index.html file located in simple_path's base dir.
  #
  type.index_path (simple_path String) path =>
    index_file (pages_dir simple_path)


  # From a URL path, find the corresponding content identifier, or FORBIDDEN /
  # MISSING in case this does not exist.
  #
  module type.get_contents (s Session, path_from_url0 String) access =>
    res := mut access forbidden
    path_from_url := mut path_from_url0

    if path_from_url.starts_with "/"
      path_from_url <- path_from_url.substring 1
      p := path.of path_from_url

      if !p.is_absolute && p = p.normalize && (content_dir.resolve p).normalize.starts_with content_dir
        if path_from_url.ends_with ".html"
          path_from_url <- path_from_url.substring 0 (path_from_url.find_last ".html").get

        match template path_from_url
          missing =>
            dir := base_dir path_from_url
            access_file := dir.resolve (path.of "access.txt")
            access := config_file.open access_file.as_string
            content_path := dir.resolve (file_path path_from_url)

            if path_from_url.ends_with ".png" || path_from_url.ends_with ".svg" || path_from_url.ends_with ".jpg" || path_from_url.ends_with ".jpeg" || path_from_url.ends_with ".pdf"
              if access_permitted s.get_user path_from_url
                res <- identifier.new content_path path_from_url
            else
              res <- missing
              match access.get "template"
                nil => s.log "no template defined in {access_file}"
                t String =>
                  res <- identifier (dir.resolve t) path_from_url content_path
          i identifier => res <- i
          forbidden =>

    res.get


  # helper to find a template's identifier
  #
  module type.template (path_from_url String) access =>
    p := templates_dir.resolve path_from_url
    is_valid_file :=
      io.file.stat
        .stats p.as_string
        .bind (.is_regular)
        .get false
    if is_valid_file
      identifier.new p nil
    else
      missing


  # constants
  #
  type.content_dir path => (path.of "./content").normalize
  type.pages_dir_relative path => path.of "pages"
  module type.templates_dir path => (path.of "./templates").normalize


# identifies a page alongside a template to send to the user
#
module identifier (module file_to_send option path,
                   module simple_path option String,
                   content_path option path) is

  is_html_template := content_path.exists


  module type.new (file_to_send option path,
                   simple_path option String) identifier =>
    identifier file_to_send simple_path nil


  module get_bytes (s Session) outcome (array u8) =>
    match file_to_send
      fts path =>
        match util.read_file fts.as_string
          ba array u8 =>
            if is_html_template
              s.set_current (simple_path.get "")
              s.add_session_info_to_html_bytes ba
            else
              ba
          e error => e
      nil => error "no file to send"


# indicates a page that is missing
#
module missing is


# indicates a page that the user is not allowed to access
#
module forbidden is


# type denoting access to a resource
#
module access : choice missing forbidden identifier is
