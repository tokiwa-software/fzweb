# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature content
#
# -----------------------------------------------------------------------

# content -- features for working with the content stored on the file system
#
module content is

  # Base directory corresponding to simple_path.
  #
  # This base directory will contain the pages subdirectory
  # and the access.txt file.
  #
  type.base_dir (simple_path String) path =>
    bp := base_simple_path simple_path
    bp?? ? content_dir.resolve bp.get : content_dir


  # Base directory corresponding to simple_path, or nil
  # if it could not be found.
  #
  # This base directory will contain the pages subdirectory
  # and the access.txt file.
  #
  module type.base_simple_path (simple_path String) option path =>
    sp := path.of simple_path

    for i := sp.names.count, i-1
    while i > 0
      base_simple_path := sp.subpath 0 i
      base_dir0 := content_dir.resolve base_simple_path
      access := base_dir0.resolve "access.txt"
    until io.file.exists access.as_string
      base_simple_path
    else
      nil



  # The file part of a simple_path.
  #
  module type.file_path (simple_path String) path =>
    bp := base_simple_path simple_path
    sp := path.of simple_path
    start i32 := bp!! ? 0 : bp.get.names.count
    end i32 := sp.names.count
    start < end ? sp.subpath start end : path.of ""


  # look the given attribute in the access.txt file
  # for simple_path
  #
  type.access_attr (simple_path, attribute, default String) String =>
    access_file := (base_dir simple_path).resolve "access.txt"
    c := config_file.open access_file.as_string
    c[attribute].or_else default


  # Check if access to a given path is permitted for user u.
  #
  module type.access_permitted (u option user, simple_path String) bool =>
    groups := access_attr simple_path "groups" ""
    match u
      u0 user => u0.check_group_access groups
      nil =>
        for
          s in (groups.split " ")
        until s = "all"
          true
        else
          false


  # Check if the given path points to a directory that contains an index.html
  # file that contains a <browse> tag to browse a directory.
  #
  type.is_browsable (jndex path) option (lock_free.Map String String) =>
    if io.file.exists jndex.as_string
      util
        .read_file_as_string jndex.as_string
        .bind str->
          for
            l in str.split "\n"
            m := document.get_tag l "<browse"
          until m.exists
            outcome m.get
          else
            error "not found"
        .as_option
    else
      nil


  # pages dir for a given path prefix
  #
  type.pages_dir (simple_path String) path =>
    (base_dir simple_path).resolve pages_dir_relative


  # index file for a given directory containing pages
  #
  type.index_file (pages path) path =>
    pages.resolve "index.html"


  # Get the relative directory from a <browse> tag. This is either
  # the value of the attribute "dir" or, if attribute "userdata" is
  # "true", the user directory.
  #
  type.get_dir_from_browse (u option user, data_path path, map lock_free.Map String String) option String =>
    if "true" = (map["userdata"].val "false")
      u.bind String u0->
        ud := path.of u0.base_dir
        ru := data_path.parent.get.relativize ud
        ru.as_string
    else
      map["dir"]


  # check if a file is known to be preformatted
  #
  module type.is_known_preformatted_file (file_name String) bool =>
    for sfx in [".c", ".fz", ".fuzion", ".sh", ".txt", ".ebnf"]
    until file_name.ends_with sfx

  # Get the data path to the contents of the given simple URL path after it had
  # been checked that we have permission to access it.
  #
  type.get_data_path2 (u option user, simple_path String) path =>
    pages := pages_dir simple_path
    html_file := mut simple_path

    if !(html_file.ends_with ".html") && !(is_known_preformatted_file html_file)
      html_file <- html_file + ".html"

    r := pages.resolve (file_path html_file)
    if !(io.file.exists r.as_string)
      index_file pages
      # NYI browsing
    else
      r


  type.path_from_access (simple_path, attribute, default String) path =>
    val := access_attr simple_path attribute default
    bd := base_dir simple_path
    bd.resolve val


  # Get the data path to the contents of the given simple URL path and check if
  # the given user (or nil if none) is allowed to access it.
  #
  module type.get_data_path (u option user, simple_path String) path =>
    if access_permitted u simple_path
      get_data_path2 u simple_path
    else
      if u!!
        path_from_access simple_path "alternative.need.login" "need_login.html"
      else
        path_from_access simple_path "alternative.access.denied" "access_denied.html"


  # Determine the index.html file located in simple_path's base dir.
  #
  type.index_path (simple_path String) path =>
    index_file (pages_dir simple_path)


  # From a URL path, find the corresponding content identifier, or FORBIDDEN /
  # MISSING in case this does not exist.
  #
  # NYI: CLEANUP: reduce code nesting
  #
  module type.get_contents (s Session, path_from_url0 String) access =>
    res := mut access forbidden
    path_from_url := mut path_from_url0

    if path_from_url.starts_with "/"
      path_from_url <- path_from_url.substring 1
      p := path.of path_from_url

      if !p.is_absolute && (content_dir.resolve p).starts_with content_dir
        if path_from_url.ends_with ".html"
          path_from_url <- path_from_url.substring 0 (path_from_url.find_last ".html").get

        match template path_from_url
          missing =>
            dir := base_dir path_from_url
            access_file := dir.resolve (path.of "access.txt")
            content_path := dir.resolve (file_path path_from_url)

            if (for sfx in [".png", ".svg", ".jpg", ".jpeg", ".pdf"]
                until path_from_url.ends_with sfx)
              if access_permitted s.get_user path_from_url
                res <- identifier.new content_path path_from_url
            else
              res <- missing
              match (config_file.open access_file.as_string)["template"]
                nil => s.log "no template defined in {access_file}"
                t String =>
                  res <- identifier (dir.resolve t) path_from_url content_path
          i identifier => res <- i
          forbidden =>

    res.get


  # helper to find a template's identifier
  #
  module type.template (path_from_url String) access =>
    p := templates_dir.resolve path_from_url
    is_valid_file :=
      io.file.stat
        .stats p.as_string
        .bind (.is_regular)
        .val false
    if is_valid_file
      identifier.new p nil
    else
      missing


  # constants
  #
  type.content_dir path => (path.of "./content")
  type.pages_dir_relative path => path.of "pages"
  module type.templates_dir path => (path.of "./templates")

