# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature document
#
# -----------------------------------------------------------------------

# document -- features used to work with documents served by the webserver
#
module document is

  # takes a page filename and removes the HTML suffix, or returns
  # index if the filename is empty
  #
  module strip_html(page String) String =>
    if page.ends_with ".html" || page.ends_with ".htm"
      page.substring 0 (page.find ".").get
    else if page = ""
      "index"
    else
      page


  # added the html extension to the page filename
  #
  module add_html(page String) String =>
    if !content.is_known_preformatted_file page
      page + ".html"
    else
      page


  # read lines from the path and return them in a list of string
  # NYI: pretty printing
  #
  module read_all_lines (file Java.java.nio.file.Path,
                         return_nil_on_error, pretty_print bool)
                        option (list String) =>
    res := util
      .read_file_as_string file.toString

    match res
      e error =>
        logger.log "error reading from path {file.toString}: {e}"
        if return_nil_on_error
          nil
        else
          ["--error reading file--"].as_list
      str String => str.split "\n"


  # same as read_all_lines (3 args) but without the option
  # for pretty printing
  #
  read_all_lines (file Java.java.nio.file.Path,
                  return_nil_on_error bool)
                 option (list String) =>
    read_all_lines file return_nil_on_error false


  # same as read_all_lines (2 args) but without the option of
  # returning nil on error
  #
  module read_all_lines (file Java.java.nio.file.Path) list String =>
    (read_all_lines file false).get


  # given a `link` and a path `page_file`, attempt to extract the title of
  # the page at `page_file`.
  #
  # this is done by searching for the first `<h1>` tag and extracting the
  # title between the opening tag and the closing tag.
  #
  # if this fails, return the file name as given by `link`, without an `html`
  # suffix, as the title.
  #
  module get_title (link String, page_file Java.java.nio.file.Path) String =>
    title_start_open := "<h1"
    title_start_close := ">"
    title_end := "</h1>"

    for
      line in document.read_all_lines page_file
      start_open := (line.find title_start_open).get -1
      start_close :=
        if start_open >= 0
          (line.find title_start_close (start_open + title_start_open.byte_length)).get -1
        else -1
      end :=
        if start_close >= 0
          (line.find title_end (start_close + title_start_close.byte_length)).get -1
        else -1
    until start_close >= 0 && end >= 0
      line.substring (start_close + title_start_close.byte_length) end
    else
      strip_html (content.file_path link).toString


  # create attribute_map based on the entry provided
  #
  module attribute_map (entry String) lock_free.Map String String =>
    map := util.url_encoded.parse_urlencoded_map entry
    res := (lock_free.Map String String).empty
    for pair in map.items do
      if (pair.1.starts_with "\"") && (pair.1.ends_with "\"")
        v := pair.1.substring 1 pair.1.byte_length
        res.put pair.0 v
      else
        res.put pair.0 pair.1
    res


  # extraction of the tag content from the string s
  #
  module get_tag (s, tag String) option (lock_free.Map String String) =>
    match s.find tag
      c i32 =>
        match s.find "/>" c+tag.byte_length
          ce i32 =>
            entry := s.substring c+tag.byte_length ce
            attribute_map entry
          nil => nil
      nil => nil
