# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature Session
#
# -----------------------------------------------------------------------

# Session -- facilities providing the session management for the Fuzion
# webserver
#
module Session (sessions lock_free.Sieve_Cache String Session,
                feeds Feeds,
                client net.ip_address,
                old_session option Session) ref is


  # session belongs to which user, if at all?
  #
  module user := concur.atomic (option user) .new nil


  # login state of the session
  #
  login := concur.atomic util.login_status .new util.unauthenticated


  # activity information
  # NYI: not thread-safe!
  #
  last_activity := concur.atomic (option time.date_time) .new nil
  count_activities := concur.atomic u64 .new 0


  # connection tied to this session for sending events to the client
  #
  connection := concur.atomic (option net.connection) .new nil


  # session history information
  #
  current_page := concur.atomic session_document .new (session_document "index" Session.this)
  last_pushed_history := concur.atomic (option session_document) .new nil


  # initialize user and login state
  #
  match old_session
    nil => unit
    old_s Session =>
      Session.this.user.write old_s.user.read
      login.write old_s.login.read


  # session id
  #
  module session_id String := uuid.create_random.as_string


  # put session in global session list
  #
  _ := sessions.access session_id ()->Session.this


  # and log session creation
  #
  log "new session {session_id} for {client} user {user.read.bind x->x.login}"


  # log session activity
  #
  activity =>
    count_activities.write (count_activities.read + 1)
    last_activity.write time.now.get


  # authenticate the session with a user account
  #
  module login (name, password String) =>
    activity

    match user.get name password
      error =>
        login.write util.auth_fail
      u user =>
        Session.this.user.write u
        login.write util.authenticated

    send_content


  # logout the session
  #
  module logout =>
    activity

    user.write nil
    login.write util.unauthenticated

    send_content


  # login state easy access
  #
  module get_login_status util.login_status =>
    login.read


  # access to session user
  #
  module get_user option user =>
    Session.this.user.read


  # send login status to client
  #
  module send_login_status unit =>
    match login.read
      util.authenticated => send_event "isLoggedIn" user.read.get.name
      * => send_event "isNotLoggedIn"


  # session status string
  #
  module status_string =>
    match login.read
      util.unauthenticated => "not logged in"
      util.auth_fail => "failed"
      util.authenticated => "ok: {user.read.get.name}"


  # send an event on the session's connection
  #
  send_event (event String) =>
    send_event event nil


  # send events along with data on the session's connection
  #
  send_event (event String, html_encoded_data option String) =>
    data := html_encoded_data.val ""
    send_data "event: {event}\ndata: {data}\n\n"


  # send history information about session's visited pages
  #
  send_push_history =>
    last := last_pushed_history.read
    c := current_page.read

    if last.is_nil || c.page != last.val.page
      last_pushed_history.write c
      send_event "pushHistory" "/{c.page}"


  # send data on the session's connection
  #
  module send_data (msg String) =>
    match connection.read
      nil => log "failed to send {msg.lines[0]}, connection is nil"
      c net.connection =>
        reset_connection_timer

        r := lm.instate_self (outcome unit) ()->
          c.with (outcome unit) lm ()->
            final_msg := "{msg.byte_length.hex}\r\n{msg}\r\n"
            io.buffered lm
              .writer.env
              .write final_msg.utf8
              .and_then _->(io.buffered lm).writer.env.flush

        match r
          unit => unit
          e error => close_connection e


  # resets connection timer
  #
  reset_connection_timer =>
    unit # NYI


  # associate a session with a connection
  #
  module set_connection (c net.connection) =>
    reset_connection_timer

    match connection.read
      nil =>
        log "Set original connection"
        connection.write c
        send_login_status
      net.connection =>
        log "Set new connection"
        close_connection unit
        connection.write c
        send_content
        send_login_status


  # close session connection
  #
  close_connection (o outcome unit) =>
    match o
      e error => log "exception when sending content: {e}"
      unit =>

    match connection.read
      nil => unit
      c net.connection =>
        log "closing connection of session: {session_id}"
        match c.close
          unit =>
          e error => log "error closing connection: {e}"
        _ := connection.write nil


  # does this session have a connection associated?
  #
  module is_connection_ok =>
    connection.read.ok


  # log a message for this session, either to the general log if
  # the session is not authenticated, or to the users' individual log
  #
  module log (msg String) =>
    match Session.this.user.read
      nil => logger.log msg
      u user => u.log msg


  # find a session by id and client
  #
  module type.get (sessions lock_free.Sieve_Cache String Session, id String, c net.ip_address) option Session =>
    match sessions.get id
      nil =>
        logger.log "No session found in map for id: {id}"
        nil
      s Session =>
        if s.client = c
          s
        else
          logger.log "Mismatch of clients for session with id: {id}"
          nil


  # find session and attach original session, or create new
  # session
  #
  module type.get (sessions lock_free.Sieve_Cache String Session,
                   feeds Feeds,
                   old_id, id option String,
                   c net.ip_address) Session =>
    res := mut (option Session) nil
    orig := mut (option Session) nil

    if old_id??
      orig <- get sessions old_id.get c
    else if id??
      res <- get sessions id.get c

    res.get.or_else (Session sessions feeds c orig)


  # send events along with data on the session's connection
  #
  module send_event(event, field_name, field_data String) =>
    html_encoded_data := encodings.html.encode "{field_name}\n{prepend_data (field_data.split "\n").as_array}" true
    send_event event html_encoded_data


######################  NYI: CLEANUP: REMOVE THIS CODE START ##############################


  # NYI: BUG: this should be in base lib

  # split sequence at s, if there is no limit, otherwise if limit is an integer n,
  # for at most n occurrences of s
  #
  # if split_after is true, all but the last element of the resulting list include
  # the separator
  #
  # helper feature which unifies the code of the different split features in one
  #
  Sequence.split2(s Sequence T, limit option u32, split_after bool) container.expanding_array (Sequence T)
    pre
      T : property.equatable
      debug: !s.is_empty
      debug: match limit
              nil => true
              n u32 => n > 0

    post
      debug: match limit
              nil => true
              n u32 => result.count.as_u32 <= n+1
    =>

      abs := s.as_array_backed

      for cnt  := u32 1,
                  cnt+1
          res  := container.expanding_array (Sequence T) .empty,
                  res.add (rest.take (if split_after then idx.get + abs.count else idx.get))
          rest := as_array_backed,
                  rest.drop (idx.get + abs.count)
          idx  := rest.find abs
      while idx.ok && (limit.is_empty || limit >=? cnt) do

      else
        res
          .add rest


  # NYI: BUG: this should be in base lib

  # split string at s
  #
  String.split2(s String) Sequence String
    pre
      !s.is_empty
    =>
      utf8.split2 s.utf8 nil false
          .map_to_array String.type.from


######################  NYI: CLEANUP: REMOVE THIS CODE END ##############################


  # NYI: comment, revisit (originally intended for StringBuilder)
  #
  prepend_data(data array String) String =>
    for res := container.expanding_array String .empty, (line.split2 "\n").reduce res (r,t -> r.add "data: $t")
        line in data
    else
      String.join res "\n"


  module add_session_info_to_html_bytes (b array u8) array u8 =>
    activity
    # NYI
    # - ByteArray from flang_dev

    cp := current_page.read

    String
      .from b
      .replace "##SESSION_ID##" session_id
      .replace "##URL##" "/{cp.page}"
      .replace "##CONTENT##" (String.join (cp.get_content feeds) "\n")
      .utf8
      .as_array


  # the message to send via an event connection
  #
  module event_msg =>
    """
      id: 0
      event: content
      {prepend_data (current_page.read.get_content feeds)}\n
    """

  # send current page content to the client
  #
  module send_content =>
    send_data event_msg
    send_push_history


  # set the current page
  #
  module set_current (page String) =>
    p := document.strip_html page
    d := session_document p Session.this
    current_page.write d


# local mutate effect used in this file
#
lm : mutate is
