# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature path
#
# -----------------------------------------------------------------------

private:module path(public names array String, public is_absolute bool) : property.equatable
pre debug: !names.contains "."
    # allow ".." only at start in relative paths
    safety: is_absolute && !names.contains ".."
            || !(names.drop_while ="..").contains ".."
is

  public resolve(o path|String) path =>
    match o
      p path => p.is_absolute ? p : (path.of names++p.names is_absolute)
      s String => resolve (path.of s)

  public subpath(x, y i32) path =>
    sp := names
      .slice x y
    path.of sp false

  public file_name String
    pre debug: !names.is_empty
  =>
    names.last.get

  # return the suffix of the file at this path
  #
  public suffix String
    pre debug: !file_name.is_empty
  =>
    file_name.split "." .last.get

  public parent option path
  =>
    if names.is_empty
      nil
    else
      path.of (names.reverse.drop 1).reverse is_absolute

  public relativize(o path) path
    pre o.is_absolute
        o.as_string.starts_with path.this.as_string
  =>
    path.of (o.names.drop names.count) false

  public starts_with(p path) bool =>
    is_absolute = p.is_absolute &&
      p.names.count <= names.count &&
      (names.take p.names.count) = p.names

  public redef as_string String =>
    (if is_absolute then "/" else "") + (if names.is_empty then "." else String.join names "/" )

  public redef type.equality(a, b path.this) bool =>
    a.is_absolute = b.is_absolute && a.names = b.names

  public type.of(str String) path =>
    t := str.trim
    path.of (t.split "/").as_array (t.starts_with "/")

  public type.of(seq Sequence String, is_absolute bool) path =>
    dotdot, names := seq
      .reverse
      .filter !="."
      .filter !=""
      .reduce (0, Sequence String .empty) (r,t)->
        if t = ".."
          # we have double dots, ignore them and increase counter
          (r.0+1, r.1)
        else if r.0 > 0
          # we previously encountered double dots.
          # ignore this element too and decrease the counter.
          (r.0-1, r.1)
        else
          # no double dots encountered previously,
          # we need to include this element in the final path
          (r.0, [t]++r.1)
    path ([".."]*dotdot ++ names).as_array is_absolute
